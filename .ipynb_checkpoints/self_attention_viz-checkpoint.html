<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Self-Attention Mechanism: Step-by-Step Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f8f9fa;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 2.2em;
        }

        .subtitle {
            text-align: center;
            color: #6c757d;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .step-navigation {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .step-btn {
            padding: 12px 20px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            background: white;
            color: #495057;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .step-btn:hover {
            border-color: #6c757d;
            background: #f8f9fa;
        }

        .step-btn.active {
            background: #495057;
            color: white;
            border-color: #495057;
        }

        .visualization-area {
            background: #fafbfc;
            border-radius: 8px;
            padding: 30px;
            margin-bottom: 20px;
            min-height: 500px;
            border: 1px solid #e9ecef;
        }

        .step-content {
            display: none;
        }

        .step-content.active {
            display: block;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .step-title {
            font-size: 1.8em;
            color: #2c3e50;
            margin-bottom: 20px;
            text-align: center;
        }

        /* Token Display */
        .tokens-container {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .token {
            padding: 12px 20px;
            background: #e9ecef;
            color: #495057;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            border: 2px solid transparent;
            position: relative;
        }

        .token:hover {
            background: #dee2e6;
            border-color: #6c757d;
        }

        .token.selected {
            background: #495057;
            color: white;
            border-color: #495057;
        }

        .token.highlighted {
            background: #d1ecf1;
            border-color: #bee5eb;
            color: #0c5460;
        }

        /* Matrix Display */
        .matrix-section {
            margin: 30px 0;
        }

        .matrix-container {
            display: flex;
            justify-content: space-around;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .matrix {
            background: white;
            border-radius: 8px;
            padding: 20px;
            border: 1px solid #e9ecef;
            min-width: 200px;
        }

        .matrix h3 {
            text-align: center;
            margin-bottom: 15px;
            color: #495057;
            font-size: 1.2em;
        }

        .matrix-grid {
            display: grid;
            gap: 2px;
            justify-content: center;
        }

        .matrix-cell {
            width: 60px;
            height: 45px;
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 600;
            color: #495057;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .matrix-cell:hover {
            background: #e9ecef;
            border-color: #6c757d;
        }

        .matrix-cell.highlighted {
            background: #d1ecf1;
            border-color: #bee5eb;
            color: #0c5460;
        }

        /* Attention Scores Grid */
        .attention-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 2px;
            max-width: 500px;
            margin: 20px auto;
        }

        .attention-cell {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .attention-cell.header {
            background: #6c757d;
            color: white;
            font-weight: 700;
        }

        .attention-cell.row-header {
            background: #adb5bd;
            color: white;
            font-weight: 700;
        }

        .attention-cell.score {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            color: #495057;
        }

        .attention-cell.score:hover {
            background: #e9ecef;
            border-color: #6c757d;
        }

        /* Attention Weights Display */
        .weights-container {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .weight-item {
            text-align: center;
            padding: 15px;
            background: white;
            border-radius: 8px;
            border: 1px solid #e9ecef;
            min-width: 120px;
        }

        .weight-label {
            font-size: 14px;
            color: #6c757d;
            margin-bottom: 5px;
        }

        .weight-value {
            font-size: 18px;
            font-weight: 700;
            color: #495057;
        }

        .weight-bar {
            width: 100%;
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            margin-top: 8px;
            overflow: hidden;
        }

        .weight-fill {
            height: 100%;
            background: #6c757d;
            transition: width 0.5s ease;
        }

        /* Context Vector Display */
        .context-vector {
            background: white;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #e9ecef;
            text-align: center;
            margin: 20px 0;
        }

        .vector-values {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        .vector-component {
            padding: 10px 15px;
            background: #f8f9fa;
            border-radius: 6px;
            font-family: monospace;
            font-weight: 600;
            color: #495057;
            border: 1px solid #e9ecef;
        }

        /* Explanation Panel */
        .explanation {
            background: white;
            padding: 25px;
            border-radius: 8px;
            margin-top: 20px;
            border-left: 4px solid #6c757d;
            border: 1px solid #e9ecef;
        }

        .explanation h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .explanation p {
            color: #495057;
            margin-bottom: 12px;
            line-height: 1.6;
        }

        .explanation strong {
            color: #2c3e50;
        }

        /* Interactive Controls */
        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .control-label {
            font-weight: 600;
            color: #495057;
            font-size: 14px;
        }

        select {
            padding: 8px 12px;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            background: white;
            color: #495057;
            font-weight: 600;
        }

        /* Formula Display */
        .formula {
            background: white;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #e9ecef;
            text-align: center;
            margin: 20px 0;
            font-family: 'Times New Roman', serif;
            font-size: 1.2em;
        }

        .formula-step {
            margin: 10px 0;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 6px;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            .step-navigation {
                flex-direction: column;
                align-items: center;
            }
            
            .matrix-container {
                flex-direction: column;
                align-items: center;
            }
            
            .attention-grid {
                grid-template-columns: repeat(4, 1fr);
                max-width: 300px;
            }
        }

        /* Accessibility */
        .token:focus,
        .matrix-cell:focus,
        .attention-cell:focus,
        .step-btn:focus {
            outline: 2px solid #0066cc;
            outline-offset: 2px;
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Self-Attention Mechanism</h1>
        <p class="subtitle">Step-by-step visualization using: "Your journey starts with one step"</p>

        <div class="step-navigation">
            <button class="step-btn active" onclick="showStep(0)" tabindex="0">
                Step 1: Input Tokens
            </button>
            <button class="step-btn" onclick="showStep(1)" tabindex="0">
                Step 2: Q, K, V Matrices
            </button>
            <button class="step-btn" onclick="showStep(2)" tabindex="0">
                Step 3: Attention Scores
            </button>
            <button class="step-btn" onclick="showStep(3)" tabindex="0">
                Step 4: Softmax Weights
            </button>
            <button class="step-btn" onclick="showStep(4)" tabindex="0">
                Step 5: Context Vector
            </button>
        </div>

        <div class="visualization-area">
            <!-- Step 0: Input Tokens -->
            <div id="step-0" class="step-content active">
                <h2 class="step-title">Step 1: Input Token Embeddings</h2>
                
                <div class="controls">
                    <div class="control-group">
                        <label class="control-label">Select Query Token:</label>
                        <select id="tokenSelect" onchange="selectToken(this.value)">
                            <option value="0">Your (x¹)</option>
                            <option value="1" selected>journey (x²)</option>
                            <option value="2">starts (x³)</option>
                            <option value="3">with (x⁴)</option>
                            <option value="4">one (x⁵)</option>
                            <option value="5">step (x⁶)</option>
                        </select>
                    </div>
                </div>

                <div class="tokens-container" id="tokens-step0">
                    <!-- Populated by JavaScript -->
                </div>

                <div class="matrix-section">
                    <h3 style="text-align: center; color: #495057;">Input Embeddings (3D vectors)</h3>
                    <div class="matrix">
                        <div class="matrix-grid" id="input-embeddings" style="grid-template-columns: repeat(3, 1fr);">
                            <!-- Populated by JavaScript -->
                        </div>
                    </div>
                </div>

                <div class="explanation">
                    <h3>Understanding Input Tokens</h3>
                    <p><strong>Token Embeddings:</strong> Each word is converted into a 3-dimensional vector that captures semantic meaning.</p>
                    <p><strong>Your Task:</strong> Select different query tokens to see how each one will compute attention with respect to all others.</p>
                    <p><strong>Current Selection:</strong> We're focusing on how "<span id="current-query-token">journey</span>" (x²) attends to all tokens in the sequence.</p>
                </div>
            </div>

            <!-- Step 1: Q, K, V Matrices -->
            <div id="step-1" class="step-content">
                <h2 class="step-title">Step 2: Computing Query, Key, and Value Matrices</h2>
                
                <div class="formula">
                    <div>Q = X × W<sub>q</sub></div>
                    <div>K = X × W<sub>k</sub></div>
                    <div>V = X × W<sub>v</sub></div>
                </div>

                <div class="matrix-container">
                    <div class="matrix">
                        <h3>Query (Q)</h3>
                        <p style="text-align: center; font-size: 12px; color: #6c757d; margin-bottom: 10px;">What am I looking for?</p>
                        <div class="matrix-grid" id="query-matrix" style="grid-template-columns: repeat(2, 1fr);">
                            <!-- Populated by JavaScript -->
                        </div>
                    </div>
                    <div class="matrix">
                        <h3>Key (K)</h3>
                        <p style="text-align: center; font-size: 12px; color: #6c757d; margin-bottom: 10px;">What can I provide?</p>
                        <div class="matrix-grid" id="key-matrix" style="grid-template-columns: repeat(2, 1fr);">
                            <!-- Populated by JavaScript -->
                        </div>
                    </div>
                    <div class="matrix">
                        <h3>Value (V)</h3>
                        <p style="text-align: center; font-size: 12px; color: #6c757d; margin-bottom: 10px;">What information to aggregate?</p>
                        <div class="matrix-grid" id="value-matrix" style="grid-template-columns: repeat(2, 1fr);">
                            <!-- Populated by JavaScript -->
                        </div>
                    </div>
                </div>

                <div class="explanation">
                    <h3>Linear Transformations</h3>
                    <p><strong>Query (Q):</strong> Represents what information the current token is seeking from other tokens.</p>
                    <p><strong>Key (K):</strong> Represents what information each token can provide to others.</p>
                    <p><strong>Value (V):</strong> Contains the actual information content that will be weighted and aggregated.</p>
                    <p><strong>Process:</strong> Each input embedding is multiplied by learned weight matrices to produce Q, K, and V representations.</p>
                </div>
            </div>

            <!-- Step 2: Attention Scores -->
            <div id="step-2" class="step-content">
                <h2 class="step-title">Step 3: Computing Attention Scores</h2>
                
                <div class="formula">
                    <div>Attention Scores = Q × K<sup>T</sup></div>
                    <div class="formula-step">For token "<span id="query-token-step2">journey</span>": q² · k<sub>i</sub> for all i</div>
                </div>

                <div style="text-align: center; margin: 20px 0;">
                    <h3 style="color: #495057;">Attention Score Matrix</h3>
                    <div class="attention-grid" id="attention-scores-grid">
                        <!-- Populated by JavaScript -->
                    </div>
                </div>

                <div class="explanation">
                    <h3>Dot Product Computation</h3>
                    <p><strong>Process:</strong> For the selected query token, we compute dot products with all key vectors (including itself).</p>
                    <p><strong>Interpretation:</strong> Higher scores indicate stronger compatibility between the query and key.</p>
                    <p><strong>Current Focus:</strong> Row for "<span id="query-explanation">journey</span>" shows how it scores against all tokens.</p>
                    <p><strong>Self-Attention:</strong> Notice how each token also attends to itself (diagonal elements).</p>
                </div>
            </div>

            <!-- Step 3: Attention Weights -->
            <div id="step-3" class="step-content">
                <h2 class="step-title">Step 4: Softmax Normalization</h2>
                
                <div class="formula">
                    <div>Attention Weights = softmax(Attention Scores / √d<sub>k</sub>)</div>
                    <div class="formula-step">Scaled by √2 = 1.414 to prevent saturation</div>
                </div>

                <div class="tokens-container" id="tokens-step3">
                    <!-- Populated by JavaScript -->
                </div>

                <div class="weights-container" id="attention-weights-display">
                    <!-- Populated by JavaScript -->
                </div>

                <div class="explanation">
                    <h3>Probability Distribution</h3>
                    <p><strong>Softmax Function:</strong> Converts raw scores into probabilities that sum to 1.0.</p>
                    <p><strong>Scaling Factor:</strong> Division by √d<sub>k</sub> prevents gradients from becoming too small during training.</p>
                    <p><strong>Interpretation:</strong> Each weight represents how much the query token should focus on each key token.</p>
                    <p><strong>Current Query:</strong> "<span id="weights-query-token">journey</span>" pays most attention to tokens with highest weights.</p>
                </div>
            </div>

            <!-- Step 4: Context Vector -->
            <div id="step-4" class="step-content">
                <h2 class="step-title">Step 5: Computing Context Vector</h2>
                
                <div class="formula">
                    <div>Context Vector = Σ(Attention Weights × Values)</div>
                    <div class="formula-step">z² = α₂₁v¹ + α₂₂v² + α₂₃v³ + α₂₄v⁴ + α₂₅v⁵ + α₂₆v⁶</div>
                </div>

                <div class="context-vector">
                    <h3>Context Vector for "<span id="context-query-token">journey</span>"</h3>
                    <div class="vector-values" id="context-vector-values">
                        <!-- Populated by JavaScript -->
                    </div>
                    <p style="margin-top: 15px; color: #6c757d;">This enriched representation incorporates information from all tokens, weighted by relevance.</p>
                </div>

                <div class="explanation">
                    <h3>Weighted Aggregation</h3>
                    <p><strong>Final Step:</strong> The context vector is computed as a weighted sum of all value vectors.</p>
                    <p><strong>Weights:</strong> Attention weights determine how much each value vector contributes.</p>
                    <p><strong>Result:</strong> Each token now has an enriched representation that captures relationships with all other tokens.</p>
                    <p><strong>Usage:</strong> This context vector replaces the original embedding and is passed to the next layer of the transformer.</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Data from the PDF example
        const tokens = ["Your", "journey", "starts", "with", "one", "step"];
        
        // Input embeddings (3D) from the PDF
        const inputEmbeddings = [
            [0.43, 0.15, 0.89],  // Your
            [0.55, 0.87, 0.66],  // journey  
            [0.57, 0.85, 0.64],  // starts
            [0.22, 0.58, 0.33],  // with
            [0.77, 0.25, 0.10],  // one
            [0.05, 0.80, 0.55]   // step
        ];

        // Weight matrices (simplified for demo)
        const Wq = [
            [0.5, 0.3],
            [0.8, 0.1],
            [0.2, 0.9]
        ];
        
        const Wk = [
            [0.4, 0.6],
            [0.7, 0.2],
            [0.1, 0.8]
        ];
        
        const Wv = [
            [0.3, 0.7],
            [0.9, 0.1],
            [0.5, 0.4]
        ];

        let currentStep = 0;
        let selectedToken = 1; // Default to "journey"

        // Compute Q, K, V matrices
        function matrixMultiply(A, B) {
            const result = [];
            for (let i = 0; i < A.length; i++) {
                const row = [];
                for (let j = 0; j < B[0].length; j++) {
                    let sum = 0;
                    for (let k = 0; k < B.length; k++) {
                        sum += A[i][k] * B[k][j];
                    }
                    row.push(sum);
                }
                result.push(row);
            }
            return result;
        }

        const Q = matrixMultiply(inputEmbeddings, Wq);
        const K = matrixMultiply(inputEmbeddings, Wk);
        const V = matrixMultiply(inputEmbeddings, Wv);

        // Compute attention scores
        function computeAttentionScores() {
            const scores = [];
            for (let i = 0; i < Q.length; i++) {
                const row = [];
                for (let j = 0; j < K.length; j++) {
                    let score = 0;
                    for (let k = 0; k < Q[i].length; k++) {
                        score += Q[i][k] * K[j][k];
                    }
                    row.push(score);
                }
                scores.push(row);
            }
            return scores;
        }

        const attentionScores = computeAttentionScores();

        // Softmax function
        function softmax(arr) {
            const maxVal = Math.max(...arr);
            const exp = arr.map(x => Math.exp(x - maxVal));
            const sum = exp.reduce((a, b) => a + b, 0);
            return exp.map(x => x / sum);
        }

        // Scaled softmax (divide by sqrt(d_k))
        function scaledSoftmax(arr) {
            const dk = K[0].length; // dimension of key vectors
            const scaled = arr.map(x => x / Math.sqrt(dk));
            return softmax(scaled);
        }

        function showStep(step) {
            currentStep = step;
            
            // Update step buttons
            document.querySelectorAll('.step-btn').forEach((btn, i) => {
                btn.classList.toggle('active', i === step);
            });
            
            // Hide all steps
            document.querySelectorAll('.step-content').forEach(el => {
                el.classList.remove('active');
            });
            
            // Show current step
            document.getElementById(`step-${step}`).classList.add('active');
            
            // Update content based on step
            updateStepContent(step);
        }

        function selectToken(tokenIndex) {
            selectedToken = parseInt(tokenIndex);
            updateStepContent(currentStep);
        }

        function updateStepContent(step) {
            switch(step) {
                case 0:
                    updateStep0();
                    break;
                case 1:
                    updateStep1();
                    break;
                case 2:
                    updateStep2();
                    break;
                case 3:
                    updateStep3();
                    break;
                case 4:
                    updateStep4();
                    break;
            }
        }

        function updateStep0() {
            // Update token selector
            document.getElementById('tokenSelect').value = selectedToken;
            
            // Update tokens display
            const tokensContainer = document.getElementById('tokens-step0');
            tokensContainer.innerHTML = '';
            tokens.forEach((token, i) => {
                const tokenEl = document.createElement('div');
                tokenEl.className = 'token';
                tokenEl.textContent = `${token} (x${i+1})`;
                tokenEl.onclick = () => {
                    selectToken(i);
                    document.getElementById('tokenSelect').value = i;
                };
                if (i === selectedToken) {
                    tokenEl.classList.add('selected');
                }
                tokensContainer.appendChild(tokenEl);
            });

            // Update input embeddings matrix
            const embeddingsGrid = document.getElementById('input-embeddings');
            embeddingsGrid.innerHTML = '';
            inputEmbeddings.forEach((embedding, tokenIdx) => {
                embedding.forEach((value, dimIdx) => {
                    const cell = document.createElement('div');
                    cell.className = 'matrix-cell';
                    cell.textContent = value.toFixed(2);
                    if (tokenIdx === selectedToken) {
                        cell.classList.add('highlighted');
                    }
                    embeddingsGrid.appendChild(cell);
                });
            });

            // Update explanation
            document.getElementById('current-query-token').textContent = tokens[selectedToken];
        }

        function updateStep1() {
            // Update Q matrix
            const qGrid = document.getElementById('query-matrix');
            qGrid.innerHTML = '';
            Q.forEach((row, tokenIdx) => {
                row.forEach(value => {
                    const cell = document.createElement('div');
                    cell.className = 'matrix-cell';
                    cell.textContent = value.toFixed(3);
                    if (tokenIdx === selectedToken) {
                        cell.classList.add('highlighted');
                    }
                    qGrid.appendChild(cell);
                });
            });

            // Update K matrix
            const kGrid = document.getElementById('key-matrix');
            kGrid.innerHTML = '';
            K.forEach((row, tokenIdx) => {
                row.forEach(value => {
                    const cell = document.createElement('div');
                    cell.className = 'matrix-cell';
                    cell.textContent = value.toFixed(3);
                    if (tokenIdx === selectedToken) {
                        cell.classList.add('highlighted');
                    }
                    kGrid.appendChild(cell);
                });
            });

            // Update V matrix
            const vGrid = document.getElementById('value-matrix');
            vGrid.innerHTML = '';
            V.forEach((row, tokenIdx) => {
                row.forEach(value => {
                    const cell = document.createElement('div');
                    cell.className = 'matrix-cell';
                    cell.textContent = value.toFixed(3);
                    if (tokenIdx === selectedToken) {
                        cell.classList.add('highlighted');
                    }
                    vGrid.appendChild(cell);
                });
            });
        }

        function updateStep2() {
            document.getElementById('query-token-step2').textContent = tokens[selectedToken];
            document.getElementById('query-explanation').textContent = tokens[selectedToken];

            const scoresGrid = document.getElementById('attention-scores-grid');
            scoresGrid.innerHTML = '';

            // Header row
            scoresGrid.appendChild(createCell('', 'header'));
            tokens.forEach(token => {
                scoresGrid.appendChild(createCell(token, 'header'));
            });

            // Data rows
            attentionScores.forEach((row, i) => {
                scoresGrid.appendChild(createCell(tokens[i], 'row-header'));
                row.forEach((score, j) => {
                    const cell = createCell(score.toFixed(3), 'score');
                    if (i === selectedToken) {
                        cell.style.background = '#d1ecf1';
                        cell.style.borderColor = '#bee5eb';
                        cell.style.color = '#0c5460';
                    }
                    scoresGrid.appendChild(cell);
                });
            });
        }

        function createCell(content, type) {
            const cell = document.createElement('div');
            cell.className = `attention-cell ${type}`;
            cell.textContent = content;
            return cell;
        }

        function updateStep3() {
            document.getElementById('weights-query-token').textContent = tokens[selectedToken];

            // Update tokens display
            const tokensContainer = document.getElementById('tokens-step3');
            tokensContainer.innerHTML = '';
            tokens.forEach((token, i) => {
                const tokenEl = document.createElement('div');
                tokenEl.className = 'token';
                tokenEl.textContent = token;
                tokenEl.onclick = () => selectToken(i);
                if (i === selectedToken) {
                    tokenEl.classList.add('selected');
                }
                tokensContainer.appendChild(tokenEl);
            });

            // Compute attention weights for selected token
            const weights = scaledSoftmax(attentionScores[selectedToken]);

            // Update weights display
            const weightsContainer = document.getElementById('attention-weights-display');
            weightsContainer.innerHTML = '';
            weights.forEach((weight, i) => {
                const weightEl = document.createElement('div');
                weightEl.className = 'weight-item';
                weightEl.innerHTML = `
                    <div class="weight-label">${tokens[i]}</div>
                    <div class="weight-value">${(weight * 100).toFixed(1)}%</div>
                    <div class="weight-bar">
                        <div class="weight-fill" style="width: ${weight * 100}%"></div>
                    </div>
                `;
                weightsContainer.appendChild(weightEl);
            });
        }

        function updateStep4() {
            document.getElementById('context-query-token').textContent = tokens[selectedToken];

            // Compute context vector
            const weights = scaledSoftmax(attentionScores[selectedToken]);
            const contextVector = [0, 0]; // 2D output
            
            for (let i = 0; i < tokens.length; i++) {
                for (let j = 0; j < 2; j++) {
                    contextVector[j] += weights[i] * V[i][j];
                }
            }

            // Update context vector display
            const valuesContainer = document.getElementById('context-vector-values');
            valuesContainer.innerHTML = '';
            contextVector.forEach((value, i) => {
                const comp = document.createElement('div');
                comp.className = 'vector-component';
                comp.textContent = value.toFixed(4);
                valuesContainer.appendChild(comp);
            });
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            showStep(0);
        });
    </script>
</body>
</html>